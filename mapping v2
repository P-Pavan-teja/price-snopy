import streamlit as st
from snowflake.snowpark import Session
import pandas as pd
import datetime
import json

# Page configuration
st.set_page_config(
    page_title="Snowflake Metadata Mapping Tool",
    page_icon="❄️",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS parameters that affect element sizing and spacing
st.markdown("""
<style>
    .stButton button {
        width: 100%;
        border-radius: 5px;
        height: 3rem;
        font-weight: bold;
    }
    .target-column {
        height: 42px !important;
        min-height: 42px !important;
        max-height: 42px !important;
        border: 1px solid #ced4da !important;
        border-radius: 0.25rem !important;
        margin: 7.8px !important;
        padding: 0px 10px !important;
        display: flex !important;
        align-items: center !important;
        box-sizing: border-box !important;
    }
    .stSelectbox > div[data-baseweb="select"] > div {
        height: 42px !important;
        min-height: 42px !important;
        max-height: 42px !important;
        margin: 0 !important;
        padding: 0 !important;
    }
        
    div[data-testid="stButton"] > button {
        height: 42px !important;
        min-height: 42px !important;
        max-height: 42px !important;
        margin: 0 !important;
        border: 1px solid #ced4da !important;
        border-radius: 0.25rem !important;
        font-size: 14px !important;
        font-weight: 400 !important;
        box-shadow: none !important;
        box-sizing: border-box !important;
    }
</style>
""", unsafe_allow_html=True)

# Initialize session state
if 'db_list' not in st.session_state:
    st.session_state.db_list = []
if 'schema_list' not in st.session_state:
    st.session_state.schema_list = []
if 'table_list' not in st.session_state:
    st.session_state.table_list = []
if 'selected_db' not in st.session_state:
    st.session_state.selected_db = None
if 'selected_schema' not in st.session_state:
    st.session_state.selected_schema = None
if 'selected_table' not in st.session_state:
    st.session_state.selected_table = None
if 'source_db_list' not in st.session_state:
    st.session_state.source_db_list = []
if 'mapping_id' not in st.session_state:
    st.session_state.mapping_id = None
if 'source_schema_list' not in st.session_state:
    st.session_state.source_schema_list = []
if 'source_table_list' not in st.session_state:
    st.session_state.source_table_list = []
if 'selected_source_db' not in st.session_state:
    st.session_state.selected_source_db = None
if 'selected_source_schema' not in st.session_state:
    st.session_state.selected_source_schema = None
if 'selected_source_table' not in st.session_state:
    st.session_state.selected_source_table = None
if 'join_sources' not in st.session_state:
    st.session_state.join_sources = []
if 'join_source_columns' not in st.session_state:
    st.session_state.join_source_columns = {}
if 'join_conditions' not in st.session_state:
    st.session_state.join_conditions = {}
if 'source_table_added' not in st.session_state:
    st.session_state.source_table_added = False
if 'current_join_selection' not in st.session_state:
    st.session_state.current_join_selection = "No"
if 'insert_successful' not in st.session_state:
    st.session_state.insert_successful = False
if 'show_transformation_editor' not in st.session_state:
    st.session_state.show_transformation_editor = False
if 'current_transform_column' not in st.session_state:
    st.session_state.current_transform_column = None
if 'editor_content' not in st.session_state:
    st.session_state.editor_content = ""
if 'function_stack' not in st.session_state:
    st.session_state.function_stack = []
if 'function_categories' not in st.session_state:
    st.session_state.function_categories = None
if 'mapping_saved' not in st.session_state:
    st.session_state.mapping_saved = False

    
# Main app header
st.title("❄️ Snowflake Metadata Mapping Tool")
st.markdown("Create and manage data transformation mappings")
st.info("Target table: COLLAB_DB.UTL_SC.META_DATA_MAPPING_TABLE_V2")

# Function to fetch databases
def fetch_databases():
    try:
        session = Session.builder.getOrCreate()
        result = session.sql("SELECT DATABASE_NAME FROM INFORMATION_SCHEMA.DATABASES ORDER BY DATABASE_NAME ASC").collect()
        return [row["DATABASE_NAME"] for row in result]
    except Exception as e:
        st.error(f"Error fetching databases: {e}")
        return []

# Function to fetch schemas for a selected database
def fetch_schemas(database):
    try:
        session = Session.builder.getOrCreate()
        result = session.sql(f"SELECT SCHEMA_NAME FROM {database}.INFORMATION_SCHEMA.SCHEMATA ORDER BY SCHEMA_NAME ASC").collect()
        return [row["SCHEMA_NAME"] for row in result]
    except Exception as e:
        st.error(f"Error fetching schemas: {e}")
        return []

# Function to fetch tables for a selected database and schema
def fetch_tables(database, schema):
    try:
        session = Session.builder.getOrCreate()
        result = session.sql(f"SELECT TABLE_NAME FROM {database}.INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '{schema}' AND TABLE_TYPE = 'BASE TABLE' ORDER BY TABLE_NAME ASC").collect()
        return [row["TABLE_NAME"] for row in result]
    except Exception as e:
        st.error(f"Error fetching tables: {e}")
        return []

# Function to fetch table columns
def fetch_table_columns(database, schema, table):
    try:
        session = Session.builder.getOrCreate()
        result = session.sql(f"SELECT COLUMN_NAME, ORDINAL_POSITION FROM {database}.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '{schema}' AND TABLE_NAME = '{table}' ORDER BY ORDINAL_POSITION ASC").collect()
        return [{"name": row["COLUMN_NAME"], "position": row["ORDINAL_POSITION"]} for row in result]
    except Exception as e:
        st.error(f"Error fetching columns for {database}.{schema}.{table}: {e}")
        return []

def get_column_name(column):
    """Extract the column name from a column object or return the column if it's a string."""
    if isinstance(column, dict) and "name" in column:
        return column["name"]
    return column

# Function to insert mapping data into the target metadata table
# Function to insert mapping data into the target metadata table
def insert_mapping_data():
    try:
        target_metadata_table = "COLLAB_DB.UTL_SC.META_DATA_MAPPING_TABLE_V2"
        session = Session.builder.getOrCreate()
        target_table = f"{st.session_state.selected_db}.{st.session_state.selected_schema}.{st.session_state.selected_table}"
        source_table = f"{st.session_state.selected_source_db}.{st.session_state.selected_source_schema}.{st.session_state.selected_source_table}"
        
       # Get short names for tables
        target_short = target_table.split('.')[-1]
        source_short = source_table.split('.')[-1]
        
        # Generate a timestamp with format YYYYMMDD
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Create the mapping ID
        st.session_state.mapping_id = f"{target_short}_{source_short}_{timestamp}"
        
        st.session_state.mapping_saved = True
        st.success("Column mapping and transformations saved successfully!")
            
        inserted_count = 0
        
        # 1. Insert target table config
        insert_sql = f"""
        INSERT INTO {target_metadata_table} (
            MAPPING_ID,
            CONFIG_KEY,
            CONFIG_VALUE,
            TARGET_COLUMN,
            TGT_ORDIANAL_POSITION,
            SOURCE_COLUMN,
            TRANSFORMATION
        ) VALUES (
            '{mapping_id}',
            'target_table_name',
            '{target_table}',
            NULL,
            NULL,
            NULL,
            NULL
        )
        """
        session.sql(insert_sql).collect()
        inserted_count += 1
        
        # 2. Insert source table config
        insert_sql = f"""
        INSERT INTO {target_metadata_table} (
            MAPPING_ID,
            CONFIG_KEY,
            CONFIG_VALUE,
            TARGET_COLUMN,
            TGT_ORDIANAL_POSITION,
            SOURCE_COLUMN,
            TRANSFORMATION
        ) VALUES (
            '{mapping_id}',
            'source_table_name',
            '{source_table}',
            NULL,
            NULL,
            NULL,
            NULL
        )
        """
        session.sql(insert_sql).collect()
        inserted_count += 1
        
        # 3. Insert joined tables config
        for source in st.session_state.join_sources:
            insert_sql = f"""
            INSERT INTO {target_metadata_table} (
                MAPPING_ID,
                CONFIG_KEY,
                CONFIG_VALUE,
                TARGET_COLUMN,
                TGT_ORDIANAL_POSITION,
                SOURCE_COLUMN,
                TRANSFORMATION
            ) VALUES (
                '{mapping_id}',
                'join_table_name',
                '{source}',
                NULL,
                NULL,
                NULL,
                NULL
            )
            """
            session.sql(insert_sql).collect()
            inserted_count += 1
        
        # 4. Insert join conditions
        for source in st.session_state.join_sources:
            if source in st.session_state.join_conditions:
                join_type = st.session_state.join_conditions[source].get('join_type', 'INNER JOIN')
                
                if st.session_state.join_conditions[source].get('manual_condition'):
                    join_info = f"{join_type} {source} ON {st.session_state.join_conditions[source]['manual_condition']}"
                else:
                    conditions = []
                    target_table_short = st.session_state.selected_table
                    source_table_short = source.split('.')[-1]
                    
                    for t_col, s_col in zip(
                        st.session_state.join_conditions[source]['target_columns'],
                        st.session_state.join_conditions[source]['source_columns']
                    ):
                        conditions.append(f"{target_table_short}.{t_col} = {source_table_short}.{s_col}")
                    
                    if conditions:
                        join_info = f"{join_type} {source} AS {source_table_short} ON {' AND '.join(conditions)}"
                    else:
                        continue
                
                insert_sql = f"""
                INSERT INTO {target_metadata_table} (
                    MAPPING_ID,
                    CONFIG_KEY,
                    CONFIG_VALUE,
                    TARGET_COLUMN,
                    TGT_ORDIANAL_POSITION,
                    SOURCE_COLUMN,
                    TRANSFORMATION
                ) VALUES (
                    '{mapping_id}',
                    'join_condition',
                    '{join_info}',
                    NULL,
                    NULL,
                    NULL,
                    NULL
                )
                """
                session.sql(insert_sql).collect()
                inserted_count += 1
        
        # 5. Insert column mappings
        for tcol in st.session_state.target_columns:
            target_column = get_column_name(tcol)
            ordinal_position = tcol["position"]
            
            if target_column in st.session_state.column_mapping:
                source_column = st.session_state.column_mapping[target_column]
                transformation = st.session_state.transformations.get(target_column, "")
                
                # Determine source table for this column
                source_table_for_column = ""
                source_col_to_check = get_column_name(source_column)
                
                # Check main source table first
                main_source = f"{st.session_state.selected_source_db}.{st.session_state.selected_source_schema}.{st.session_state.selected_source_table}"
                found_in_main = False
                
                for col in st.session_state.join_source_columns[main_source]:
                    if source_col_to_check == get_column_name(col):
                        source_table_for_column = main_source
                        found_in_main = True
                        break
                
                # If not in main source, check joined tables
                if not found_in_main:
                    for joined_source in st.session_state.join_sources:
                        for col in st.session_state.join_source_columns[joined_source]:
                            if source_col_to_check == get_column_name(col):
                                source_table_for_column = joined_source
                                break
                        if source_table_for_column:
                            break
                
                insert_sql = f"""
                INSERT INTO {target_metadata_table} (
                    MAPPING_ID,
                    CONFIG_KEY,
                    CONFIG_VALUE,
                    TARGET_COLUMN,
                    TGT_ORDIANAL_POSITION,
                    SOURCE_COLUMN,
                    TRANSFORMATION
                ) VALUES (
                    '{mapping_id}',
                    'columns',
                    NULL,
                    '{target_column}',
                    {ordinal_position},
                    '{source_column}',
                    '{transformation}'
                )
                """
                session.sql(insert_sql).collect()
                inserted_count += 1
        
        return True, f"Successfully inserted {inserted_count} entries into {target_metadata_table} with mapping ID: {mapping_id}"
    except Exception as e:
        return False, f"Error inserting mapping data: {e}"
def fetch_sql_functions():
    """Fetch SQL functions from Snowflake"""
    try:
        session = Session.builder.getOrCreate()
        df = session.sql("SELECT ID, CATEGORY, NAME, CODE, HELP, TYPE FROM COPY_DB.PUBLIC.sql_functions").to_pandas()
        df.columns = [col.lower() for col in df.columns]
        
        function_categories = {}
        for category, group in df.groupby("category"):
            function_categories[category] = []
            for _, row in group.iterrows():
                function_categories[category].append({
                    "name": row["name"],
                    "code": row["code"],
                    "help": row.get("help", ""),
                    "type": row["type"]
                })
        
        return function_categories
    except Exception as e:
        st.error(f"Error fetching SQL functions: {e}")
        # Provide fallback categories if database fetch fails
        return {
            "String Functions": [
                {"name": "UPPER", "code": "UPPER()", "help": "Convert string to uppercase", "type": "wrapper"},
                {"name": "LOWER", "code": "LOWER()", "help": "Convert string to lowercase", "type": "wrapper"},
                {"name": "TRIM", "code": "TRIM()", "help": "Remove leading and trailing whitespace", "type": "wrapper"}
            ],
            "Date Functions": [
                {"name": "CURRENT_DATE", "code": "CURRENT_DATE()", "help": "Current date", "type": "function"},
                {"name": "DATE_TRUNC", "code": "DATE_TRUNC('MONTH', )", "help": "Truncate date to specified precision", "type": "wrapper"}
            ],
            "Numeric Functions": [
                {"name": "ROUND", "code": "ROUND(, 2)", "help": "Round number to specified decimal places", "type": "wrapper"},
                {"name": "ABS", "code": "ABS()", "help": "Absolute value", "type": "wrapper"}
            ],
            "Conditional Logic": [
                {"name": "CASE", "code": "CASE WHEN  THEN  ELSE  END", "help": "Conditional logic", "type": "template"},
                {"name": "COALESCE", "code": "COALESCE(, )", "help": "Return first non-null value", "type": "wrapper"},
                {"name": "NULLIF", "code": "NULLIF(, )", "help": "Return null if values are equal", "type": "wrapper"}
            ]
        }

# Add these helper functions for the transformation editor
def apply_function(function_code, function_type):
    """Add a function to the stack to be applied to a column"""
    st.session_state.function_stack.append({
        "code": function_code,
        "type": function_type
    })
    
def apply_column(column_name):
    """Apply the function stack to a column and add it to the editor content"""
    if st.session_state.function_stack:
        # Apply functions in reverse order (innermost first)
        result = column_name
        
        for func in reversed(st.session_state.function_stack):
            if func["type"] == "wrapper":
                # For functions like UPPER()
                func_code = func["code"]
                open_paren_index = func_code.index("(")
                comma_index = func_code.find(",", open_paren_index)
                
                if comma_index > -1:
                    result = func_code[:open_paren_index+1] + result + func_code[comma_index:]
                else:
                    close_paren_index = func_code.rindex(")")
                    result = func_code[:open_paren_index+1] + result + func_code[close_paren_index:]
            
            elif func["type"] == "operator":
                result = func["code"] + result
            
            elif func["type"] == "template":
                func_code = func["code"]
                if "WHEN" in func_code and "THEN" in func_code:
                    when_index = func_code.index("WHEN")
                    result = func_code[:when_index+5] + " " + result + " " + func_code[when_index+5:]
                else:
                    result = func_code.replace("condition", result)
        
        st.session_state.editor_content += result
        st.session_state.function_stack = []
    else:
        # No functions, just insert the column
        st.session_state.editor_content += column_name

def open_transformation_editor(column_name):
    """Open the transformation editor for a specific column"""
    st.session_state.show_transformation_editor = True
    st.session_state.current_transform_column = column_name
    st.session_state.editor_content = st.session_state.transformations.get(column_name, "")
    st.session_state.function_stack = []

def close_transformation_editor():
    """Close the transformation editor without saving"""
    st.session_state.show_transformation_editor = False
    st.session_state.current_transform_column = None
    st.session_state.editor_content = ""
    st.session_state.function_stack = []

def apply_transformation():
    """Apply the transformation to the current column and close the editor"""
    if st.session_state.current_transform_column:
        transformation = st.session_state.editor_content.strip()
        if transformation:
            st.session_state.transformations[st.session_state.current_transform_column] = transformation
        elif st.session_state.current_transform_column in st.session_state.transformations:
            # Remove transformation if it's empty
            del st.session_state.transformations[st.session_state.current_transform_column]
    
    close_transformation_editor()

def handle_transform_button(column_name):
    open_transformation_editor(column_name)
    st.rerun()

def generate_preview_query():
    """Generate a SQL query to preview source data with joins"""
    if not st.session_state.mapping_saved:
        return None
    
    # Get the main source table
    main_source = f"{st.session_state.selected_source_db}.{st.session_state.selected_source_schema}.{st.session_state.selected_source_table}"
    main_table_alias = st.session_state.selected_source_table
    
    # Collect mapped source columns
    columns_to_select = []
    
    for tcol, source_col in st.session_state.column_mapping.items():
        target_col_name = get_column_name(tcol)  
        source_col_name = get_column_name(source_col) 

        if target_col_name in st.session_state.transformations and st.session_state.transformations[target_col_name]:
            transform_expr = st.session_state.transformations[target_col_name]
            
            # Find which table this column belongs to
            for src, columns in st.session_state.join_source_columns.items():
                table_alias = src.split('.')[-1]

                for col in columns:
                    col_name = get_column_name(col)
                    if col_name in transform_expr:
                        transform_expr = transform_expr.replace(
                            col_name, 
                            f"{table_alias}.{col_name}"
                        )
            columns_to_select.append(f"{transform_expr} AS {target_col_name}")
        else:
            for src, columns in st.session_state.join_source_columns.items():
                column_names = [get_column_name(col) for col in columns]
                if source_col_name in column_names:
                    table_alias = src.split('.')[-1]
                    columns_to_select.append(f"{table_alias}.{source_col_name} AS {target_col_name}")
                    break
    
    if not columns_to_select:
        return None
    
    # Build the query
    select_clause = ", ".join(columns_to_select)
    from_clause = f"{main_source} AS {main_table_alias}"
    
    # Add join clauses
    join_clauses = []
    for joined_source in st.session_state.join_sources:
        joined_table_alias = joined_source.split('.')[-1]
        
        if joined_source in st.session_state.join_conditions:
            join_type = st.session_state.join_conditions[joined_source].get('join_type', 'INNER JOIN')
            
            if st.session_state.join_conditions[joined_source].get('manual_condition'):
                # Replace table names with aliases in the manual condition
                manual_condition = st.session_state.join_conditions[joined_source]['manual_condition']
                
                # Simply use the manual condition as is, assuming it uses the correct aliases
                join_clause = f"{join_type} {joined_source} AS {joined_table_alias} ON {manual_condition}"
            else:
                # Use the column-based join
                conditions = []
                for t_col, s_col in zip(
                    st.session_state.join_conditions[joined_source]['target_columns'],
                    st.session_state.join_conditions[joined_source]['source_columns']
                ):
                    conditions.append(f"{main_table_alias}.{t_col} = {joined_table_alias}.{s_col}")
                
                if conditions:
                    join_clause = f"{join_type} {joined_source} AS {joined_table_alias} ON {' AND '.join(conditions)}"
                else:
                    # Skip this join if no conditions
                    continue
            
            join_clauses.append(join_clause)
    
    # Complete the query
    query = f"SELECT {select_clause} FROM {from_clause}"
    if join_clauses:
        query += " " + " ".join(join_clauses)
    
    # Add LIMIT
    query += " LIMIT 10"
    
    return query

def execute_preview_query(query):
    """Execute the preview query and return results"""
    try:
        session = Session.builder.getOrCreate()
        result = session.sql(query).to_pandas()
        return result, None
    except Exception as e:
        return None, f"Error executing preview query: {e}"

# Initialize db_list if empty
if not st.session_state.db_list:
    with st.spinner("Fetching databases..."):
        st.session_state.db_list = fetch_databases()
        st.session_state.source_db_list = st.session_state.db_list

# Create columns for target selections
col1, col2, col3 = st.columns(3)

# Target selections
with col1:
    st.subheader("Select Target Database")
    st.selectbox(
        "Target Database",
        options=st.session_state.db_list if st.session_state.db_list else ["No options to select."],
        key="selected_db",
        on_change=lambda: st.session_state.update(schema_list=fetch_schemas(st.session_state.selected_db), selected_schema=None, table_list=[], selected_table=None, source_table_added=False)
    )

with col2:
    st.subheader("Select Target Schema")
    st.selectbox(
        "Target Schema",
        options=st.session_state.schema_list if st.session_state.schema_list else ["No options to select."],
        key="selected_schema",
        on_change=lambda: st.session_state.update(table_list=fetch_tables(st.session_state.selected_db, st.session_state.selected_schema), selected_table=None, source_table_added=False)
    )

with col3:
    st.subheader("Select Target Table")
    st.selectbox(
        "Target Table",
        options=st.session_state.table_list if st.session_state.table_list else ["No options to select."],
        key="selected_table"
    )

# Show source selections only after target table is selected
if st.session_state.selected_table:
    source_container = st.container()
    with source_container:
        st.markdown("---")
        st.subheader("Source Table Selection")
        source_cols = st.columns(3)
        
        with source_cols[0]:
            st.selectbox(
                "Source Database",
                options=st.session_state.source_db_list if st.session_state.source_db_list else ["No options to select."],
                key="selected_source_db",
                on_change=lambda: st.session_state.update(source_schema_list=fetch_schemas(st.session_state.selected_source_db), selected_source_schema=None, source_table_list=[], selected_source_table=None, source_table_added=False)
            )

        with source_cols[1]:
            st.selectbox(
                "Source Schema",
                options=st.session_state.source_schema_list if st.session_state.source_schema_list else ["No options to select."],
                key="selected_source_schema",
                on_change=lambda: st.session_state.update(source_table_list=fetch_tables(st.session_state.selected_source_db, st.session_state.selected_source_schema), selected_source_table=None, source_table_added=False)
            )

        with source_cols[2]:
            st.selectbox(
                "Source Table",
                options=st.session_state.source_table_list if st.session_state.source_table_list else ["No options to select."],
                key="selected_source_table"
            )

    if not (st.session_state.get('selected_source_db') and st.session_state.get('selected_source_schema') and st.session_state.get('selected_source_table')):
        st.info("Please select a source database, schema, and table to continue")
    
    if (st.session_state.selected_source_db and st.session_state.selected_source_schema and st.session_state.selected_source_table):
        current_source = f"{st.session_state.selected_source_db}.{st.session_state.selected_source_schema}.{st.session_state.selected_source_table}"
        
        if current_source not in st.session_state.join_source_columns:
            main_source_columns = fetch_table_columns(
                st.session_state.selected_source_db, 
                st.session_state.selected_source_schema, 
                st.session_state.selected_source_table
            )
            st.session_state.join_source_columns[current_source] = main_source_columns
            st.session_state.source_columns = main_source_columns
        
        st.markdown("---")
        st.subheader("Join Additional Source Tables")
        
        col_join = st.columns(2)
        with col_join[0]:
            join_option = st.radio(
                "Would you like to join another source table?",
                options=["No", "Yes"],
                key="current_join_selection"
            )
            
        with col_join[1]:
            if st.session_state.join_sources:
                st.write("Current joined sources:")
                for idx, source in enumerate(st.session_state.join_sources):
                    st.write(f"{idx+1}. {source}")
        
        if st.session_state.current_join_selection == "Yes":
            st.markdown("### Select Additional Source Table")
            
            if 'additional_source_db' not in st.session_state:
                st.session_state.additional_source_db = None
            if 'additional_source_schema' not in st.session_state:
                st.session_state.additional_source_schema = None
            if 'additional_source_table' not in st.session_state:
                st.session_state.additional_source_table = None
                
            def on_additional_db_select():
                if st.session_state.additional_source_db:
                    with st.spinner("Fetching schemas..."):
                        st.session_state.additional_source_schema_list = fetch_schemas(st.session_state.additional_source_db)
                    st.session_state.additional_source_schema = None
                    st.session_state.additional_source_table_list = []
                    st.session_state.additional_source_table = None

            def on_additional_schema_select():
                if st.session_state.additional_source_schema and st.session_state.additional_source_db:
                    with st.spinner("Fetching tables..."):
                        st.session_state.additional_source_table_list = fetch_tables(
                            st.session_state.additional_source_db, 
                            st.session_state.additional_source_schema
                        )
                    st.session_state.additional_source_table = None
                
            if 'additional_source_schema_list' not in st.session_state:
                st.session_state.additional_source_schema_list = []
            if 'additional_source_table_list' not in st.session_state:
                st.session_state.additional_source_table_list = []
                
            add_source_cols = st.columns(3)
            
            with add_source_cols[0]:
                st.selectbox(
                    "Additional Source Database",
                    options=st.session_state.db_list if st.session_state.db_list else ["No options to select."],
                    key="additional_source_db",
                    on_change=on_additional_db_select,
                    index=0 if st.session_state.additional_source_db is None else st.session_state.db_list.index(st.session_state.additional_source_db)
                )

            with add_source_cols[1]:
                st.selectbox(
                    "Additional Source Schema",
                    options=st.session_state.additional_source_schema_list if st.session_state.additional_source_schema_list else ["No options to select."],
                    key="additional_source_schema",
                    on_change=on_additional_schema_select,
                    index=0 if st.session_state.additional_source_schema is None else st.session_state.additional_source_schema_list.index(st.session_state.additional_source_schema)
                )

            with add_source_cols[2]:
                st.selectbox(
                    "Additional Source Table",
                    options=st.session_state.additional_source_table_list if st.session_state.additional_source_table_list else ["No options to select."],
                    key="additional_source_table",
                    index=0 if st.session_state.additional_source_table is None else st.session_state.additional_source_table_list.index(st.session_state.additional_source_table)
                )
                
            if (st.session_state.additional_source_db and st.session_state.additional_source_schema and st.session_state.additional_source_table):
                additional_source = f"{st.session_state.additional_source_db}.{st.session_state.additional_source_schema}.{st.session_state.additional_source_table}"
                
                st.markdown("### Define Join Condition")
                
                join_types = [
                    "INNER JOIN",
                    "LEFT JOIN",
                    "RIGHT JOIN",
                    "LEFT OUTER JOIN", 
                    "RIGHT OUTER JOIN", 
                    "FULL OUTER JOIN",
                ]
                
                if additional_source not in st.session_state.join_conditions:
                    st.session_state.join_conditions[additional_source] = {
                        'target_columns': [],
                        'source_columns': [],
                        'join_type': 'INNER JOIN'
                    }

                selected_join_type = st.selectbox(
                    "Join Type",
                    options=join_types,
                    index=join_types.index(st.session_state.join_conditions[additional_source]['join_type']),
                    key=f"join_type_{additional_source}"
                )
                
                st.session_state.join_conditions[additional_source]['join_type'] = selected_join_type
                
                join_col1, join_col2 = st.columns(2)
                
                with join_col1:
                    st.write("**Source Table**") 
                
                    # Fetch the source table columns
                    source_columns_full = fetch_table_columns(
                        st.session_state.selected_source_db,
                        st.session_state.selected_source_schema,
                        st.session_state.selected_source_table
                    )
                
                    source_column_names = [col["name"] for col in source_columns_full]

                    default_target_names = []
                    for col in st.session_state.join_conditions[additional_source]['target_columns']:
                        if isinstance(col, dict) and "name" in col:
                            default_target_names.append(col["name"])
                        else:
                            default_target_names.append(col)

                    selected_target_names = st.multiselect(
                        "Source Table Columns",
                        options=source_column_names,
                        default=default_target_names,
                        key=f"target_columns_{additional_source}"
                    )

                    st.session_state.join_conditions[additional_source]['target_columns'] = selected_target_names
                
                with join_col2:
                    st.write("**Join Table 1**")
                    
                    add_columns_full = fetch_table_columns(
                        st.session_state.additional_source_db,
                        st.session_state.additional_source_schema,
                        st.session_state.additional_source_table
                    )
                    
                    add_column_names = [col["name"] for col in add_columns_full]
                    
                    default_source_names = []
                    for col in st.session_state.join_conditions[additional_source]['source_columns']:
                        if isinstance(col, dict) and "name" in col:
                            default_source_names.append(col["name"])
                        else:
                            default_source_names.append(col)
                    
                    selected_source_names = st.multiselect(
                        "Join Table 1 Columns",
                        options=add_column_names,
                        default=default_source_names,
                        key=f"source_columns_{additional_source}"
                    )
                    st.session_state.join_conditions[additional_source]['source_columns'] = selected_source_names

                selected_target_columns = st.session_state.join_conditions[additional_source]['target_columns']
                selected_source_columns = st.session_state.join_conditions[additional_source]['source_columns']

                st.markdown("---")
                st.write("**Or manually enter a custom join condition:**")
                manual_join_condition = st.text_area(
                    "Custom Join Condition",
                    value=st.session_state.join_conditions.get(additional_source, {}).get('manual_condition', ''),
                    placeholder="Example: target_table.column1 = source_table.column2 AND target_table.column3 = source_table.column4",
                    help="Enter a custom join condition. If provided, this will be used instead of the column selections above."
                )

                if manual_join_condition:
                    st.session_state.join_conditions[additional_source]['manual_condition'] = manual_join_condition
                elif 'manual_condition' in st.session_state.join_conditions[additional_source]:
                    st.session_state.join_conditions[additional_source]['manual_condition'] = ""
                
                if st.session_state.join_conditions[additional_source].get('manual_condition'):
                    join_type = st.session_state.join_conditions[additional_source]['join_type']
                    st.write("**Selected Join Condition (Manual):**")
                    st.write(f"**Type:** `{join_type}`")
                    st.write("**Custom Condition:**")
                    st.code(st.session_state.join_conditions[additional_source]['manual_condition'], language="sql")
                    
                    join_statement = f"{join_type} {additional_source} ON {st.session_state.join_conditions[additional_source]['manual_condition']}"
                    st.code(join_statement, language="sql")
                elif selected_target_columns and selected_source_columns:
                    target_table_short = st.session_state.selected_table
                    source_table_short = additional_source.split('.')[-1]
                    
                    join_type = st.session_state.join_conditions[additional_source]['join_type']
                    st.write("**Selected Join Condition:**")
                    st.write(f"**Type:** `{join_type}`")
                    st.write("**On:**")
                    for target_col, source_col in zip(
                        st.session_state.join_conditions[additional_source]['target_columns'],
                        st.session_state.join_conditions[additional_source]['source_columns']
                    ):
                        st.write(f"`{target_table_short}.{target_col}` = `{source_table_short}.{source_col}`")

                    # Build join condition with table names
                    join_conditions = []
                    for target_col, source_col in zip(
                        st.session_state.join_conditions[additional_source]['target_columns'],
                        st.session_state.join_conditions[additional_source]['source_columns']
                    ):
                        join_conditions.append(f"{target_table_short}.{target_col} = {source_table_short}.{source_col}")

                    join_statement = f"{join_type} {additional_source} AS {source_table_short} ON {' AND '.join(join_conditions)}"
                    st.code(join_statement, language="sql")
                
                if st.button("Add This Source Table"):
                    if additional_source not in st.session_state.join_sources:
                        if not (st.session_state.join_conditions[additional_source].get('manual_condition') or 
                               (st.session_state.join_conditions[additional_source]['target_columns'] and 
                                st.session_state.join_conditions[additional_source]['source_columns'])):
                            st.warning("Please define join conditions before adding the source table.")
                        else:
                            st.session_state.join_sources.append(additional_source)
                            if additional_source not in st.session_state.join_source_columns:
                                joined_source_columns = fetch_table_columns(
                                    st.session_state.additional_source_db,
                                    st.session_state.additional_source_schema,
                                    st.session_state.additional_source_table
                                )
                                st.session_state.join_source_columns[additional_source] = joined_source_columns
                            st.success(f"Added {additional_source} to joined sources!")
                            st.session_state.source_table_added = True
                            st.rerun()
                    else:
                        st.warning(f"Source {additional_source} is already in the joined sources list.")
        else:
            if st.button("Continue to Column Mapping"):
                st.session_state.source_table_added = True
                st.rerun()

    if st.session_state.source_table_added:
        st.markdown("---")
        st.subheader("Column Mapping")
        
        if 'target_columns' not in st.session_state:
            st.session_state.target_columns = fetch_table_columns(
                st.session_state.selected_db, 
                st.session_state.selected_schema, 
                st.session_state.selected_table
            )
        
        all_source_columns = []
        source_column_to_table = {}
        
        main_source = f"{st.session_state.selected_source_db}.{st.session_state.selected_source_schema}.{st.session_state.selected_source_table}"
        
        for column in st.session_state.join_source_columns[main_source]:
            column_name = get_column_name(column)
            all_source_columns.append(column)
            source_column_to_table[column_name] = st.session_state.selected_source_table
        
        for source in st.session_state.join_sources:
            if source not in st.session_state.join_source_columns:
                # Fetch columns if missing
                source_parts = source.split('.')
                if len(source_parts) == 3:  # Make sure we have db.schema.table format
                    db_name, schema_name, table_name = source_parts
                    source_columns = fetch_table_columns(db_name, schema_name, table_name)
                    st.session_state.join_source_columns[source] = source_columns
                else:
                    # Initialize with empty list to prevent further errors
                    st.session_state.join_source_columns[source] = []
                    st.error(f"Unable to fetch columns for {source}. Invalid format.")
                    
            table_name = source.split('.')[-1]
            for column in st.session_state.join_source_columns[source]:
                column_name = get_column_name(column)
                existing_names = [get_column_name(col) for col in all_source_columns]
                if column_name in existing_names:
                    column_with_table = f"{column_name}_{table_name}"
                    all_source_columns.append(column)
                    source_column_to_table[column_with_table] = table_name  
                    source_column_to_table[f"_original_{column_with_table}"] = column_name  
                else:
                    all_source_columns.append(column)
                    source_column_to_table[column_name] = table_name
        
        if 'column_mapping' not in st.session_state:
            st.session_state.column_mapping = {}
            
            # Create a mapping of uppercase source column names to original column names
            uppercase_source_columns = {}
            for source, columns in st.session_state.join_source_columns.items():
                for col in columns:
                    col_name = get_column_name(col)
                    uppercase_source_columns[col_name.upper()] = (col_name, source)
    
            # Auto-map target columns to source columns based on uppercase matching
            for tcol in st.session_state.target_columns:
                column_name = get_column_name(tcol)
                if column_name.upper() in uppercase_source_columns:
                    # Get the original case column name and its source
                    original_col, source = uppercase_source_columns[column_name.upper()]
                    st.session_state.column_mapping[column_name] = original_col
            
        if 'transformations' not in st.session_state:
            st.session_state.transformations = {}
        
        st.write("Map each target column to a source column and specify any transformations:")
        
        mapping_cols = st.columns([1, 1, 2])
        
        with mapping_cols[0]:
            st.write("**Target Column (Position)**")
            for tcol in st.session_state.target_columns:
                column_name = get_column_name(tcol)
                ordinal_position = tcol["position"]
                st.markdown(f'''
                    <div class="target-column">
                        <span style="font-weight: 500; color: #212529;">{column_name}</span>
                        <span style="color: #6c757d; margin-left: auto; font-size: 0.9em;">(Pos: {ordinal_position})</span>
                    </div>
                ''', unsafe_allow_html=True)
        
        # For source columns
        with mapping_cols[1]:
            st.write("**Source Column**")
            for i, tcol in enumerate(st.session_state.target_columns):
                column_name = get_column_name(tcol)  
                key = f"mapping_{column_name}_{i}"
                
                # Source options for dropdown
                source_options = ["None"]
                for column in all_source_columns:
                    src_column_name = get_column_name(column)
                    table_name = source_column_to_table.get(src_column_name, "Unknown")
                    option_text = f"{src_column_name} ({table_name})"
                    source_options.append(option_text)
                
                # Find default selection
                default_idx = 0
                if column_name in st.session_state.column_mapping:
                    mapped_col = st.session_state.column_mapping[column_name]
                    mapped_col_name = get_column_name(mapped_col)
                    for idx, option in enumerate(source_options):
                        if option.startswith(f"{mapped_col} ("):
                            default_idx = idx
                            break
                
                selected_source_option = st.selectbox(
                    f"Map to {column_name}",
                    options=source_options,
                    index=default_idx,
                    key=key,
                    label_visibility="collapsed"
                )
                
                # Process selection
                if selected_source_option != "None":
                    selected_source = selected_source_option.split(" (")[0]
                    if "_original_" + selected_source in source_column_to_table:
                        original_column = source_column_to_table["_original_" + selected_source]
                        st.session_state.column_mapping[column_name] = original_column
                    else:
                        st.session_state.column_mapping[column_name] = selected_source
                elif column_name in st.session_state.column_mapping:
                    del st.session_state.column_mapping[column_name]
        
        # For transformation buttons
        with mapping_cols[2]:
            st.write("**Transformation (SQL)**")
            for i, tcol in enumerate(st.session_state.target_columns):
                column_name = get_column_name(tcol)
                
                # Create a container for the transform button and SQL code
                transform_container = st.container()
                
                # Create columns for button and SQL display
                btn_col, sql_col = transform_container.columns([1, 3])
                
                with btn_col:
                    transform_btn = st.button("Transform", 
                              key=f"transform_btn_{column_name}_{i}",
                              use_container_width=True)
                
                with sql_col:
                    # Display the transformation SQL if it exists
                    if column_name in st.session_state.transformations:
                        st.code(st.session_state.transformations[column_name], language="sql")
                
                # Handle transform button click
                if transform_btn:
                    handle_transform_button(column_name)
            
        # Display the transformation editor when it should be shown
        if st.session_state.show_transformation_editor and st.session_state.current_transform_column:
            st.markdown("---")
            st.subheader(f"SQL Transformation Editor - {st.session_state.current_transform_column}")
            
            # Load function categories if not already loaded
            if st.session_state.function_categories is None:
                with st.spinner("Loading SQL functions..."):
                    st.session_state.function_categories = fetch_sql_functions()
            
            # Create a container for the transformation editor
            editor_container = st.container()
            
            with editor_container:
                left_col, right_col = st.columns([1, 2])
                
                with right_col:
                    st.subheader("Build Your Transformation")
                    
                    # Create tabs for function categories
                    function_categories = st.session_state.function_categories
                    tab_names = list(function_categories.keys())
                    tabs = st.tabs(tab_names)
                    
                    # Create buttons for each function category
                    for i, (category, functions) in enumerate(function_categories.items()):
                        with tabs[i]:
                            buttons_per_row = 3
                            
                            for j in range(0, len(functions), buttons_per_row):
                                cols = st.columns(buttons_per_row)
                                
                                for k in range(buttons_per_row):
                                    col_index = j + k
                                    if col_index < len(functions):
                                        func = functions[col_index]
                                        with cols[k]:
                                            key = f"btn_{category}_{col_index}".lower().replace(" ", "_")
                                            
                                            if st.button(
                                                func["name"], 
                                                help=func.get("help", ""),
                                                key=key
                                            ):
                                                apply_function(func["code"], func["type"])
                                                st.rerun()
                    
                    # Text editor for SQL expressions
                    st.subheader("SQL Expression Editor")
                    editor_value = st.session_state.editor_content
                    editor_content = st.text_area(
                        "Edit your SQL expression directly",
                        value=editor_value,
                        height=150,
                        key="editor_area"
                    )
                    
                    # Update when editor content changes
                    if editor_content != editor_value:
                        st.session_state.editor_content = editor_content
                        st.session_state.function_stack = []
                    
                    # Preview section
                    st.markdown("---")
                    st.subheader("Transformation Preview")
                    
                    if st.session_state.editor_content:
                        st.code(f"Current transformation: {st.session_state.editor_content}")
                    else:
                        st.info("Build your transformation using the buttons above.")
                
                with left_col:
                    st.subheader("Available Columns")
                    
                    # Gather all available source columns
                    all_source_columns = []
                    for source, columns in st.session_state.join_source_columns.items():
                        table_name = source.split('.')[-1]
                        
                        with st.expander(f"Table: {table_name}", expanded=True):
                            num_cols = 1
                            column_buttons = []
                            
                            for column in columns:
                                column_name = get_column_name(column)
                                column_buttons.append(column_name)
                            
                            for j in range(0, len(column_buttons), num_cols):
                                cols = st.columns(num_cols)
                                
                                for k in range(num_cols):
                                    col_index = j + k
                                    if col_index < len(column_buttons):
                                        column = column_buttons[col_index]
                                        with cols[k]:
                                            key = f"col_{table_name}_{col_index}".lower().replace(" ", "_")
                                            
                                            if st.button(column, key=key):
                                                apply_column(column)
                                                st.rerun()
                
                # Action buttons
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    if st.button("Clear", key="clear_transform", use_container_width=True):
                        st.session_state.editor_content = ""
                        st.session_state.function_stack = []
                        st.rerun()
                
                with col2:
                    if st.button("Cancel", key="cancel_transform", use_container_width=True):
                        close_transformation_editor()
                        st.rerun()
                
                with col3:
                    if st.button("Save Transformation", key="apply_transform", type="primary", use_container_width=True):
                        apply_transformation()
                        st.rerun()
                    
        # Hide "Save Mapping" button when the transformation editor is open
        if not st.session_state.get('show_transformation_editor', False):
            if st.button("Save Mapping"):
                st.session_state.mapping_saved = True
                st.success("Column mapping and transformations saved successfully!")

        if st.session_state.mapping_saved:
            # Create data for display table
            table_data = {
                "Mapping ID": [],
                "Config Key": [],
                "Config Value": [],
                "Target Column": [],
                "Position": [],
                "Source Column": [],
                "Transformation": []
            }
            
            # Add main table config rows
            mapping_id = st.session_state.mapping_id
            target_table = f"{st.session_state.selected_db}.{st.session_state.selected_schema}.{st.session_state.selected_table}"
            source_table = f"{st.session_state.selected_source_db}.{st.session_state.selected_source_schema}.{st.session_state.selected_source_table}"
            
            # Target table row
            table_data["Mapping ID"].append(mapping_id)
            table_data["Config Key"].append("target_table_name")
            table_data["Config Value"].append(target_table)
            table_data["Target Column"].append(None)
            table_data["Position"].append(None)
            table_data["Source Column"].append(None)
            table_data["Transformation"].append(None)
            
            # Source table row
            table_data["Mapping ID"].append(mapping_id)
            table_data["Config Key"].append("source_table_name")
            table_data["Config Value"].append(source_table)
            table_data["Target Column"].append(None)
            table_data["Position"].append(None)
            table_data["Source Column"].append(None)
            table_data["Transformation"].append(None)
            
            # Add join tables
            for source in st.session_state.join_sources:
                table_data["Mapping ID"].append(mapping_id)
                table_data["Config Key"].append("join_table_name")
                table_data["Config Value"].append(source)
                table_data["Target Column"].append(None)
                table_data["Position"].append(None)
                table_data["Source Column"].append(None)
                table_data["Transformation"].append(None)
            
            # Add join conditions
            for source in st.session_state.join_sources:
                if source in st.session_state.join_conditions:
                    join_type = st.session_state.join_conditions[source].get('join_type', 'INNER JOIN')
                    
                    if st.session_state.join_conditions[source].get('manual_condition'):
                        join_info = f"{join_type} {source} ON {st.session_state.join_conditions[source]['manual_condition']}"
                    else:
                        conditions = []
                        target_table_short = st.session_state.selected_table
                        source_table_short = source.split('.')[-1]
                        
                        for t_col, s_col in zip(
                            st.session_state.join_conditions[source]['target_columns'],
                            st.session_state.join_conditions[source]['source_columns']
                        ):
                            conditions.append(f"{target_table_short}.{t_col} = {source_table_short}.{s_col}")
                        
                        if conditions:
                            join_info = f"{join_type} {source} AS {source_table_short} ON {' AND '.join(conditions)}"
                        else:
                            continue
                    
                    table_data["Mapping ID"].append(mapping_id)
                    table_data["Config Key"].append("join_condition")
                    table_data["Config Value"].append(join_info)
                    table_data["Target Column"].append(None)
                    table_data["Position"].append(None)
                    table_data["Source Column"].append(None)
                    table_data["Transformation"].append(None)
            
            # Add column mappings
            for tcol in st.session_state.target_columns:
                column_name = get_column_name(tcol)
                ordinal_position = tcol["position"]
                
                if column_name in st.session_state.column_mapping:
                    source_col = st.session_state.column_mapping[column_name]
                    transform = st.session_state.transformations.get(column_name, "")
                    
                    table_data["Mapping ID"].append(mapping_id)
                    table_data["Config Key"].append("columns")
                    table_data["Config Value"].append(None)
                    table_data["Target Column"].append(column_name)
                    table_data["Position"].append(ordinal_position)
                    table_data["Source Column"].append(source_col)
                    table_data["Transformation"].append(transform)
            
            # Create DataFrame and display
            df = pd.DataFrame(table_data)
            # Rename columns to match the actual table structure
            df = df.rename(columns={
                "Position": "TGT_ORDIANAL_POSITION",
                "Config Key": "CONFIG_KEY",
                "Config Value": "CONFIG_VALUE",
                "Mapping ID": "MAPPING_ID",
                "Target Column": "TARGET_COLUMN",
                "Source Column": "SOURCE_COLUMN",
                "Transformation": "TRANSFORMATION"
            })
            st.table(df)

            st.markdown("---")
            st.subheader("Preview Source Data")
            
            preview_query = generate_preview_query()
            
            if preview_query:
                if st.button("show Sample Data"):
                    with st.spinner("Fetching sample data..."):
                        result_df, error = execute_preview_query(preview_query)
                        
                        if error:
                            st.error(error)
                        elif result_df is not None and not result_df.empty:
                            st.markdown("##### Sample Data (10 rows):")
                            st.dataframe(result_df)
                        else:
                            st.warning("No data returned from query.")
            else:
                st.info("Please map at least one column to view sample data.")
        
            st.markdown("---")
            st.subheader("Insert Mapping Data")
            st.markdown('<div class="insert-button">', unsafe_allow_html=True)
            if st.button("Insert Mapping Data"):
                success, message = insert_mapping_data()
                if success:
                    st.session_state.insert_successful = True
                    st.success(message)
                else:
                    st.error(message)
            st.markdown('</div>', unsafe_allow_html=True)
        else:
            st.markdown("---")
            st.info("Save mapping before inserting data")
        
        if st.session_state.insert_successful:
            st.success("✅ Mapping data has been successfully inserted into the database!")

# Footer
st.markdown("---")
