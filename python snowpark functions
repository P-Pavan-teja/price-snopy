Snowpark Order of Operations
	1.	session.table("...") / session.sql("...")
ðŸ‘‰ Starting point (like SQL FROM).
	2.	join()
ðŸ‘‰ Add other tables first (like SQL joins).
Note: you can also join later, but logically itâ€™s near the start.
	3.	where() / filter()
ðŸ‘‰ Row filtering (SQL WHERE).
	4.	select()
ðŸ‘‰ Choose columns, expressions, aliases (SQL SELECT).
	5.	group_by(...).agg(...)
ðŸ‘‰ Aggregation (SQL GROUP BY + aggregate functions).
	6.	having (not a direct method; use .where() on the aggregated DataFrame).
ðŸ‘‰ Equivalent of SQL HAVING.
	7.	distinct()
ðŸ‘‰ If needed (SQL SELECT DISTINCT).
	8.	order_by() / sort()
ðŸ‘‰ Sorting (SQL ORDER BY).
	9.	limit()
ðŸ‘‰ Restrict rows (SQL LIMIT).
	10.	collect() / show() / to_pandas()
ðŸ‘‰ Trigger action (execute query & bring results).


from snowflake.snowpark.functions import col, sum

df = (
    session.table("ORDERS")                                 # FROM
    .join(session.table("CUSTOMERS"), "CUSTOMER_ID")        # JOIN
    .where(col("STATUS") == "PAID")                         # WHERE
    .select("ORDER_ID", "CUSTOMER_ID", "AMOUNT")            # SELECT
    .group_by("CUSTOMER_ID").agg(sum("AMOUNT").alias("TOT"))# GROUP BY
    .where(col("TOT") > 1000)                               # HAVING
    .distinct()                                             # DISTINCT
    .order_by(col("TOT").desc())                            # ORDER BY
    .limit(5)                                               # LIMIT
)

df.show()

from snowflake.snowpark.functions import col, lit, sum, avg, upper, length, when, row_number
from snowflake.snowpark.window import Window

window_spec = Window.partition_by("CUSTOMER_ID").order_by(col("AMOUNT").desc())

df = (
    session.table("ORDERS")
    .select(
        "*",                                                # 1. All columns
        "ORDER_ID", "CUSTOMER_ID",                          # 2. Specific columns
        col("AMOUNT").alias("ORDER_AMOUNT"),                # 3. Rename
        (col("QTY") * col("PRICE")).alias("TOTAL_PRICE"),   # 4. Expression
        lit("USA").alias("COUNTRY"),                        # 5. Literal
        sum("AMOUNT").alias("TOTAL_AMOUNT"),                # 6. Aggregates
        avg("AMOUNT").alias("AVG_AMOUNT"),
        upper(col("CITY")).alias("CITY_UPPER"),             # 7. Function
        length(col("NAME")).alias("NAME_LEN"),
        when(col("AMOUNT") > 1000, "HIGH")                  # 9. CASE WHEN
          .when(col("AMOUNT") > 500, "MEDIUM")
          .otherwise("LOW")
          .alias("AMOUNT_CATEGORY"),
        row_number().over(window_spec).alias("ROW_NUM")     # 10. Window fn
    )
    .distinct()  # 8. DISTINCT
    .limit(10)
)

from snowflake.snowpark import Session
from snowflake.snowpark.functions import col, sum, length, upper, regexp_like

# Assume ORDERS table has: ORDER_ID, CUSTOMER_ID, AMOUNT, STATUS, DISCOUNT, CITY, EMAIL, COMMENT, CATEGORY, QTY, NAME

df = (
    session.table("ORDERS")
    .select("ORDER_ID", "CUSTOMER_ID", "AMOUNT", "STATUS", 
            "DISCOUNT", "CITY", "EMAIL", "COMMENT", "CATEGORY", "QTY", "NAME")
    
    # 1. Comparison
    .where(col("AMOUNT") > 500)               # AMOUNT > 500
    .where(col("STATUS") == "PAID")           # STATUS = 'PAID'
    .where(col("DISCOUNT") != 0)              # DISCOUNT <> 0
    .where(col("QTY") <= 100)                 # QTY <= 100

    # 2. Multiple conditions
    .where((col("AMOUNT") > 500) & (col("STATUS") == "PAID"))   # AND
    .where((col("QTY") < 10) | (col("DISCOUNT") > 5))           # OR
    .where(~(col("STATUS") == "CANCELLED"))                     # NOT

    # 3. String matching
    .where(col("NAME").like("%smith%"))        # LIKE '%smith%'
    .where(col("CITY").ilike("new%"))          # ILIKE 'new%'
    .where(col("EMAIL").startswith("test@"))   # EMAIL LIKE 'test@%'
    .where(col("EMAIL").endswith(".com"))      # EMAIL LIKE '%.com'
    .where(col("COMMENT").contains("error"))   # COMMENT LIKE '%error%'

    # 4. Null checks
    .where(col("DISCOUNT").is_null())          # IS NULL
    .where(col("DISCOUNT").is_not_null())      # IS NOT NULL

    # 5. Membership (IN / NOT IN)
    .where(col("STATUS").isin("PAID", "SHIPPED"))     # STATUS IN (...)
    .where(~col("CATEGORY").isin("X", "Y", "Z"))      # CATEGORY NOT IN (...)

    # 6. Between
    .where((col("AMOUNT") >= 100) & (col("AMOUNT") <= 500))  # BETWEEN

    # 7. Regular expressions
    .where(regexp_like(col("EMAIL"), r"^[A-Za-z0-9._%+-]+@gmail\.com$"))

    # 8. Expressions
    .where(length(col("NAME")) > 5)             # LENGTH(NAME) > 5
    .where(upper(col("CITY")) == "NEW YORK")    # UPPER(CITY) = 'NEW YORK'

    # Final cleanup
    .limit(10)
)

# Trigger action
for row in df.collect():
    print(row)
SELECT ORDER_ID, CUSTOMER_ID, AMOUNT, STATUS, DISCOUNT, CITY, EMAIL, COMMENT, CATEGORY, QTY, NAME
FROM ORDERS
WHERE AMOUNT > 500
  AND STATUS = 'PAID'
  AND DISCOUNT <> 0
  AND QTY <= 100
  AND (AMOUNT > 500 AND STATUS = 'PAID')
  AND (QTY < 10 OR DISCOUNT > 5)
  AND STATUS <> 'CANCELLED'
  AND NAME LIKE '%smith%'
  AND CITY ILIKE 'new%'
  AND EMAIL LIKE 'test@%'
  AND EMAIL LIKE '%.com'
  AND COMMENT LIKE '%error%'
  AND DISCOUNT IS NULL
  AND DISCOUNT IS NOT NULL
  AND STATUS IN ('PAID', 'SHIPPED')
  AND CATEGORY NOT IN ('X','Y','Z')
  AND (AMOUNT BETWEEN 100 AND 500)
  AND REGEXP_LIKE(EMAIL, '^[A-Za-z0-9._%+-]+@gmail\.com$')
  AND LENGTH(NAME) > 5
  AND UPPER(CITY) = 'NEW YORK'
LIMIT 10;
